<!DOCTYPE html>  <html> <head>   <title>parser.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               parser.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <p>A parser is a function that takes input (a string) and returns a list of
pairs: (parsing result, rest of input). Pairs are represented as two-element
arrays.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>A successful parse is non-empty list. More than one result means more than
one possible parse result.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>The simplest parsers accept single characters, but we'll combine them using
combinators like sequence() or choice(), finally leading to program() parser
which returns abstract syntax tree (AST) for whole program.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>TODO describe or remove</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nx">v</span><span class="p">,</span> <span class="nx">input</span><span class="p">]];</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">newResults</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newResults</span> <span class="o">=</span> <span class="nx">newResults</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])(</span><span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">newResults</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>Two basic building blocks for parsers are sequence() and choice().</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>sequence() accepts a list of parsers and creates new parser which will run
them consecutively. The results from each parser are passed
to "decorator" which builds a node of AST.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>decorator functions will not necesseraly use results from all parsers
in the sequence. We will add suffix _ to names of such parameters.
Later we'll see many examples of this convention.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sequence</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">decorator</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">step</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">step</span><span class="p">(</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">results</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="nx">r</span><span class="p">]));</span>
      <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ret</span><span class="p">(</span><span class="nx">decorator</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">results</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">step</span><span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="p">[])(</span><span class="nx">input</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>decorate() is a special case of sequence(), but with only one parser given.
This saves us from typing [] in such cases.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">decorate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">decorator</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">parser</span><span class="p">],</span> <span class="nx">decorator</span><span class="p">);</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>choice() will try running each of given parsers. It'll return combined
results from all of them (as list of alternatives).</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">choice</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">parsers</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">results</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">));</span>
    <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>many1() accepts many (at least one) occurences of input acceptable by given
parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">many1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">parser</span><span class="p">),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">rs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ret</span><span class="p">([</span><span class="nx">r</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">rs</span><span class="p">));</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>Same as many1(), but allows no occurences.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">many</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span> <span class="nx">many1</span><span class="p">(</span><span class="nx">parser</span><span class="p">),</span> <span class="nx">ret</span><span class="p">([])</span> <span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p>sepBy1 accepts many (at least one) occurences of input acceptable by given
parser, separated by input parsed by separator.
For example: sepBy1(symbol(","), number) will accept "12,34,5".</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sepBy1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span>
    <span class="nx">parser</span><span class="p">,</span> <span class="nx">many</span><span class="p">(</span>
      <span class="nx">sequence</span><span class="p">([</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s_</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">)],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">xs</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>Same as sepBy1, but allows no occurences.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sepBy</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span> <span class="nx">sepBy1</span><span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">),</span> <span class="nx">ret</span><span class="p">([])</span> <span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <p>debug() is a combinator that wraps a parser and prints given input every
time wrapped parser is called.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">debug</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <p>Now we're finished with combinators. We'll define real parsers.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <p>The simplest useful parser is character(c). It accepts only if first input
character equals c. As all parsers, it returns a list of pairs:
(result, remaining input).
The result is just the parsed character.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">character</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">actual</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">actual</span> <span class="o">===</span> <span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">[[</span><span class="nx">actual</span><span class="p">,</span> <span class="nx">input</span><span class="p">]];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>For given string, returns a parser that will accept and return that string.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">parsers</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">join</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">};</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">join</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>Below are some simple parsers for single characters.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">letter</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">(</span>
  <span class="s2">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span>
  <span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">));</span>

<span class="kd">var</span> <span class="nx">digit</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">(</span>
  <span class="s2">&quot;0123456789&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span>
  <span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">));</span>

<span class="kd">var</span> <span class="nx">semicolon</span> <span class="o">=</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">whiteSpace</span> <span class="o">=</span> <span class="nx">many</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">));</span></pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>This is an identity function, which skips all arguments except first one.
We'll use it when defining parsers with sequence() when only first result
is needed.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">returnFirst</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>lexeme() creates a parser that will accept the same input as given parser,
but will also skip any trailing whitespace and comments.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">lexeme</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>TODO skip comments</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">whiteSpace</span><span class="p">],</span> <span class="nx">returnFirst</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>From now on, every parser will a be lexeme parser or use lexeme parser at
its end. In other words, every parser defined below will accept and skip
trailing whitespace and comments.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>An identifier starts with a letter, followed by letters, digits
or underscores (_).</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">identifier</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">letter</span><span class="p">,</span> <span class="nx">many</span><span class="p">(</span><span class="nx">choice</span><span class="p">([</span><span class="nx">letter</span><span class="p">,</span> <span class="nx">digit</span><span class="p">,</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]))],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">);</span>
<span class="nx">identifier</span> <span class="o">=</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">identifier</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">integer</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span>
  <span class="nx">many1</span><span class="p">(</span><span class="nx">digit</span><span class="p">),</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">ds</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">ds</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">));</span> <span class="p">}</span>
<span class="p">);</span>
<span class="nx">integer</span> <span class="o">=</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">integer</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>TODO what about prefixes? e.g. fun/function?</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">keyword</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="p">}</span></pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>TODO what about = and ==?</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">operator</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>between() combines three parsers, but returns only results from "inside"
parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">between</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">inside</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">before</span><span class="p">,</span> <span class="nx">inside</span><span class="p">,</span> <span class="nx">after</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">b_</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a_</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>Given existing parser, create a new one for input wrapped in parentheses.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">parens</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>Same as parens, but with curly braces: { and }.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">braces</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>Same as parens, but with square brackets: [ and ].</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">squares</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>Now we start defining parsers that build AST.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>TODO support float numbers</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">numberLiteral</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">integer</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">numberLiteral</span><span class="o">:</span> <span class="nx">i</span> <span class="p">};</span>
<span class="p">});</span></pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>This parser is wrapped in a function, executed immediately, because we want
to define locally some simpler parsers, not visible outside.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">stringLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>TODO string literals should allow not only letters!
TODO escaping</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="kd">var</span> <span class="nx">contents</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">letter</span><span class="p">),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">})</span>

  <span class="kd">var</span> <span class="nx">inSingleQuotes</span> <span class="o">=</span> <span class="nx">between</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">),</span> <span class="nx">contents</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">inDoubleQuotes</span> <span class="o">=</span> <span class="nx">between</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">),</span> <span class="nx">contents</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">choice</span><span class="p">([</span><span class="nx">inSingleQuotes</span><span class="p">,</span> <span class="nx">inDoubleQuotes</span><span class="p">]),</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">stringLiteral</span><span class="o">:</span> <span class="nx">string</span> <span class="p">};</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">}();</span></pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>Many parsers need to be defined recursively. For example, an object literal
will contain expression, so we need to use expr parser. However, expr cannot
be defined yet, as it will need objectLiteral parser.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>That's why we wrap such recursive parsers in functions.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">objectLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">identifier</span><span class="p">,</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">s_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nx">id</span><span class="p">,</span> <span class="nx">expr</span><span class="p">];</span> <span class="p">}</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">braces</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">pair</span><span class="p">)),</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">pairs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">objectLiteral</span><span class="o">:</span> <span class="nx">pairs</span> <span class="p">};</span> <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">arrayLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">squares</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">)),</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">exprs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">arrayLiteral</span><span class="o">:</span> <span class="nx">exprs</span> <span class="p">};</span> <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">variable</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">identifier</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">variable</span><span class="o">:</span> <span class="nx">i</span> <span class="p">};</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">));</span>

  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">),</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">body</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">statements</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="nx">func</span><span class="o">:</span> <span class="p">[</span><span class="nx">args</span><span class="p">,</span> <span class="nx">statements</span><span class="p">]</span> <span class="p">};</span> <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">numberLiteral</span><span class="p">,</span>
    <span class="nx">stringLiteral</span><span class="p">,</span>
    <span class="nx">objectLiteral</span><span class="p">,</span>
    <span class="nx">arrayLiteral</span><span class="p">,</span>
    <span class="nx">variable</span><span class="p">,</span>
    <span class="nx">func</span><span class="p">,</span>
    <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
  <span class="p">])(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">varStatementWithoutAssignment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">varStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">varStatementWithAssignment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">,</span> <span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">op_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">varStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">id</span><span class="p">,</span> <span class="nx">expr</span><span class="p">]</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">varStatement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">varStatementWithAssignment</span><span class="p">,</span> <span class="nx">varStatementWithoutAssignment</span><span class="p">]);</span>

<span class="kd">var</span> <span class="nx">assignStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">lexpr</span><span class="p">,</span> <span class="nx">op_</span><span class="p">,</span> <span class="nx">rexpr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">assignStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">lexpr</span><span class="p">,</span> <span class="nx">rexpr</span><span class="p">]</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">returnStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;return&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">returnStatement</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">ifStatementWithoutElse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">ifStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">statements</span><span class="p">,</span> <span class="p">[]]</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">ifStatementWithElse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">)),</span>
      <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;else&quot;</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">statements1</span><span class="p">,</span> <span class="nx">k2_</span><span class="p">,</span> <span class="nx">statements2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">ifStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">statements1</span><span class="p">,</span> <span class="nx">statements2</span><span class="p">]</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">ifStatement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">ifStatementWithElse</span><span class="p">,</span> <span class="nx">ifStatementWithoutElse</span><span class="p">]);</span>

<span class="kd">var</span> <span class="nx">tryStatement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;try&quot;</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">)),</span>
      <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;catch&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">identifier</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">try_</span><span class="p">,</span> <span class="nx">tryStatements</span><span class="p">,</span> <span class="nx">catch_</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">catchStatements</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">tryStatement</span><span class="o">:</span> <span class="p">[</span><span class="nx">tryStatements</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">catchStatements</span><span class="p">]</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">throwStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;throw&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">t_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">throwStatement</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="nx">exprStatement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">exprStatement</span><span class="o">:</span> <span class="nx">e</span> <span class="p">};</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">sequence</span><span class="p">([</span><span class="nx">varStatement</span><span class="p">,</span>    <span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">)],</span> <span class="nx">returnFirst</span><span class="p">),</span>
    <span class="nx">sequence</span><span class="p">([</span><span class="nx">assignStatement</span><span class="p">,</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">)],</span> <span class="nx">returnFirst</span><span class="p">),</span>
    <span class="nx">sequence</span><span class="p">([</span><span class="nx">returnStatement</span><span class="p">,</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">)],</span> <span class="nx">returnFirst</span><span class="p">),</span>
    <span class="nx">sequence</span><span class="p">([</span><span class="nx">throwStatement</span><span class="p">,</span>  <span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">)],</span> <span class="nx">returnFirst</span><span class="p">),</span>
    <span class="nx">sequence</span><span class="p">([</span><span class="nx">exprStatement</span><span class="p">,</span>   <span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">)],</span> <span class="nx">returnFirst</span><span class="p">),</span></pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <p>if and try statements, unlike others, are not followed by a semicolon.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">ifStatement</span><span class="p">,</span>
    <span class="nx">tryStatement</span><span class="p">,</span></pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>But we want to allow programs with unnecessary semicolons, so we add
"empty" statement that parses to null.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">decorate</span><span class="p">(</span><span class="nx">lexeme</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="p">})</span>
<span class="p">]);</span></pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>A program consists of many statements.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">program</span> <span class="o">=</span> <span class="nx">many1</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>The runner for parsers. By default uses "program" parser.
It will apply parser to the input, reject any incomplete parses (i.e. those
with any remaining input) and return first AST from the list.
This is means that if there is more than one successful parse, all but first
one are discarded.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">exports</span><span class="p">.</span><span class="nx">parse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">parser</span> <span class="o">=</span> <span class="nx">parser</span> <span class="o">||</span> <span class="nx">program</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">completeResults</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ast</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">completeResults</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">success</span><span class="o">:</span> <span class="nx">completeResults</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">failure</span><span class="o">:</span> <span class="nx">results</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>Here we export any parsers that we want to test individually.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">exports</span><span class="p">.</span><span class="nx">expr</span> <span class="o">=</span> <span class="nx">expr</span><span class="p">;</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 