<!DOCTYPE html>  <html> <head>   <title>parser.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>            <div id="jump_to">         Jump To &hellip;         <div id="jump_wrapper">           <div id="jump_page">                                           <a class="source" href="ast.html">                 ast.js               </a>                                           <a class="source" href="parser.html">                 parser.js               </a>                        </div>         </div>       </div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               parser.js             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <p>A parser is a function that takes input (a string) and returns a list of
pairs: (parsing result, rest of input). Pairs are represented as two-element
arrays.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p>A successful parse is non-empty list. More than one result means more than
one possible parse result.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>The simplest parsers accept single characters, but we'll combine them using
combinators like sequence() or choice(), finally leading to program() parser
which returns abstract syntax tree (AST) for whole program.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>TODO describe</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nx">v</span><span class="p">,</span> <span class="nx">input</span><span class="p">]];</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">newResults</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newResults</span> <span class="o">=</span> <span class="nx">newResults</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])(</span><span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">newResults</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <p>Two basic building blocks for parsers are sequence() and choice().</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>sequence() accepts a list of parsers and creates new parser which will run
them consecutively. The results from each parser are passed
to "decorator" which builds a node of AST.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p>decorator functions will not necesseraly use results from all parsers
in the sequence. We will add suffix _ to names of such parameters.
Later we'll see many examples of this convention.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sequence</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">decorator</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">step</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parsers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">step</span><span class="p">(</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">results</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="nx">r</span><span class="p">]));</span>
      <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ret</span><span class="p">(</span><span class="nx">decorator</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">results</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">step</span><span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="p">[])(</span><span class="nx">input</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p>decorate() is a special case of sequence(), but with only one parser given.
This saves us from typing [] in such cases.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">decorate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">decorator</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">parser</span><span class="p">],</span> <span class="nx">decorator</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>choice() will try running each of given parsers. For performance reasons
it will return first successful result. This has two consequences:
1) for ambigous results, we get only first one (not really an issue)
2) parsers should not accept prefixes of input for next parsers given to
choice(). For example, choice([string("x"), string("xy")]) will return "x"
and leave "y" as not parsed input. It can be fixed by using
choice([string("xy"), string("x")]) instead.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">choice</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">parsers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="nx">parsers</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">input</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">[];</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>Same as choice(), but tries every parser, even if one of them accepts.
Returns all successful results (i.e. concatenates results lists).
Please note it may take exponential time.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">everyChoice</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsers</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">parsers</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">results</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">results</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">));</span>
    <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p>many1() accepts many (at least one) occurences of input acceptable by given
parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">many1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">parser</span><span class="p">),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">rs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ret</span><span class="p">([</span><span class="nx">r</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">rs</span><span class="p">));</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p>Same as many1(), but allows no occurences.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">many</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span> <span class="nx">many1</span><span class="p">(</span><span class="nx">parser</span><span class="p">),</span> <span class="nx">ret</span><span class="p">([])</span> <span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>sepBy1 accepts many (at least one) occurences of input acceptable by given
parser, separated by input parsed by separator.
For example: sepBy1(symbol(","), number) will accept "12,34,5".</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sepBy1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span>
    <span class="nx">parser</span><span class="p">,</span> <span class="nx">many</span><span class="p">(</span>
      <span class="nx">sequence</span><span class="p">([</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s_</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">)],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">xs</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <p>Same as sepBy1, but allows no occurences.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">sepBy</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span> <span class="nx">sepBy1</span><span class="p">(</span><span class="nx">separator</span><span class="p">,</span> <span class="nx">parser</span><span class="p">),</span> <span class="nx">ret</span><span class="p">([])</span> <span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <p>Now we'll define combinators needed to create expressions parser.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <p>chainl1() returns parser that accepts many (at least one) occurences of
given parser, separated by op, creating parse tree for left-associative
operators. For example, chainl1(number, plus) will parse 1+2+3 as (1+2)+3,
given appropriate plus and number parsers.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">chainl1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">{</span></pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <p>rest(x) tries to parse remaining expression, which starts with operator
op. If found op, it parses next argument (y). Op is a special parser,
which returns a two-argument function. We apply this function to x and y.
The result is parsed expression: x op y.
Then we apply rest() again with this result, trying to find next part of
the expression. (e.g. x op y op z).
If next term is not found, we just return x.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="kd">var</span> <span class="nx">rest</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span>
      <span class="nx">bind</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">));</span>
        <span class="p">});</span>
      <span class="p">}),</span>
      <span class="nx">ret</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">]);</span>
  <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>Parse first part of the expression and try to parse rest.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">rest</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>prefix() allows input accepted by parser to be preceded by input accepted
by op, multiple times.
Similar to chainl1, the result from op should be a function (unary).
For example, prefix(bool, bang) will parse !true and !!true.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">prefixOp</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">sequence</span><span class="p">([</span><span class="nx">op</span><span class="p">,</span> <span class="nx">parser</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}),</span> <span class="nx">parser</span><span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>suffix() allows input accepted by parser to be followed by input accepted
by op, multiple times.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">suffixOp</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">rest</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span>
      <span class="nx">bind</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">rest</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
      <span class="p">}),</span>
      <span class="nx">ret</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">]);</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">rest</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <p>These combinators create new parser that skips leading or trailing input
accepted by toSkip and returns result from parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">skipLeading</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">toSkip</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">toSkip</span><span class="p">,</span> <span class="nx">parser</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">skipped_</span><span class="p">,</span> <span class="nx">parsed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">parsed</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">skipTrailing</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">toSkip</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">parser</span><span class="p">,</span> <span class="nx">toSkip</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parsed</span><span class="p">,</span> <span class="nx">skipped_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">parsed</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p>This combinator accepts only if suffix parser fails.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">notFollowedBy</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">suffix</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">parser</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">hasSuffix</span> <span class="o">=</span> <span class="nx">suffix</span><span class="p">(</span><span class="nx">input</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasSuffix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[[</span><span class="nx">result</span><span class="p">,</span> <span class="nx">input</span><span class="p">]];</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">});</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>debug() is a combinator that wraps a parser and prints given input every
time wrapped parser is called.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">debug</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>Now we're finished with combinators. We'll define real parsers.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>The simplest useful parser is character(c). It accepts only if first input
character equals c. As all parsers, it returns a list of pairs:
(result, remaining input).
The result is just the parsed character.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">character</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">actual</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">actual</span> <span class="o">===</span> <span class="nx">expected</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">[[</span><span class="nx">actual</span><span class="p">,</span> <span class="nx">input</span><span class="p">]];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>This parser accepts any char and returns it.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">anyChar</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)]];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
  <span class="p">}</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p>This parser accepts any char from given list of allowed chars.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">anyCharOf</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">allowed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">allowed</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[[</span><span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)]];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p>This parser accepts any char other than those from given list.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">otherThanChars</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">disallowed</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">disallowed</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[[</span><span class="nx">input</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)]];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[];</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">otherThanChar</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">disallowedChar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">otherThanChars</span><span class="p">([</span><span class="nx">disallowedChar</span><span class="p">]);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>For given string, returns a parser that will accept and return that string.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">parsers</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">join</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">};</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span><span class="nx">parsers</span><span class="p">,</span> <span class="nx">join</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p>Below are some simple parsers for single characters.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">letter</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">(</span>
  <span class="s2">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span>
  <span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">));</span>

<span class="kd">var</span> <span class="nx">digit</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">(</span>
  <span class="s2">&quot;0123456789&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span>
  <span class="nx">map</span><span class="p">(</span><span class="nx">character</span><span class="p">));</span>

<span class="kd">var</span> <span class="nx">semicolon</span> <span class="o">=</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">whiteSpace</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">character</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;\t&quot;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;\n&quot;</span><span class="p">)]);</span></pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>And parsers for comments.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">delimitedComment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span></pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <p>TODO this is broken due to not backtracking choice()</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="p">[</span><span class="nx">string</span><span class="p">(</span><span class="s2">&quot;/*&quot;</span><span class="p">),</span> <span class="nx">many</span><span class="p">(</span><span class="nx">anyChar</span><span class="p">),</span> <span class="nx">string</span><span class="p">(</span><span class="s2">&quot;*/&quot;</span><span class="p">)],</span>
  <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;comment&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">lineComment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">string</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">),</span> <span class="nx">many</span><span class="p">(</span><span class="nx">otherThanChar</span><span class="p">(</span><span class="s2">&quot;\n&quot;</span><span class="p">)),</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;\n&quot;</span><span class="p">)],</span>
  <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;comment&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">whiteSpaceOrComments</span> <span class="o">=</span> <span class="nx">many</span><span class="p">(</span><span class="nx">choice</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">whiteSpace</span><span class="p">,</span> <span class="nx">delimitedComment</span><span class="p">,</span> <span class="nx">lineComment</span><span class="p">]</span>
<span class="p">));</span></pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>lexeme() creates a parser that will accept the same input as given parser,
but will also skip any trailing whitespace and comments.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">lexeme</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">whiteSpaceOrComments</span><span class="p">,</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <p>From now on, every parser will be a lexeme parser or use lexeme parser at
its end. In other words, every parser defined below will accept and skip
trailing whitespace and comments.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <p>An identifier starts with a letter, followed by letters, digits
or underscores (_).</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">identifier</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span></pre></div>             </td>           </tr>                               <tr id="section-36">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-36">&#182;</a>               </div>               <p>TODO reject keywords</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="p">[</span><span class="nx">letter</span><span class="p">,</span> <span class="nx">many</span><span class="p">(</span><span class="nx">choice</span><span class="p">([</span><span class="nx">letter</span><span class="p">,</span> <span class="nx">digit</span><span class="p">,</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]))],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">);</span>
<span class="nx">identifier</span> <span class="o">=</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">identifier</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">integer</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span>
  <span class="nx">many1</span><span class="p">(</span><span class="nx">digit</span><span class="p">),</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">ds</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">ds</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span> <span class="p">}</span>
<span class="p">);</span>
<span class="nx">integer</span> <span class="o">=</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">integer</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">keyword</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">notFollowedBy</span><span class="p">(</span><span class="nx">letter</span><span class="p">,</span> <span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">)));</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">operator</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">notFollowedBy</span><span class="p">(</span><span class="nx">anyCharOf</span><span class="p">(</span><span class="s2">&quot;-+=&lt;&gt;!|&amp;&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)),</span> <span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">)));</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">symbol</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-37">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-37">&#182;</a>               </div>               <p>between() combines three parsers, but returns only results from "inside"
parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">between</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">inside</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">before</span><span class="p">,</span> <span class="nx">inside</span><span class="p">,</span> <span class="nx">after</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">b_</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a_</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-38">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-38">&#182;</a>               </div>               <p>Given existing parser, create a new one for input wrapped in parentheses.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">parens</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-39">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-39">&#182;</a>               </div>               <p>Same as parens, but with curly braces: { and }.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">braces</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;{&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-40">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-40">&#182;</a>               </div>               <p>Same as parens, but with square brackets: [ and ].</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">squares</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">between</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">),</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">),</span> <span class="nx">parser</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-41">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-41">&#182;</a>               </div>               <p>Now we start defining parsers that build AST.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">AST</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;ast&quot;</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-42">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-42">&#182;</a>               </div>               <p>TODO support float numbers</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">numberLiteral</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">integer</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">NumberLiteral</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">});</span></pre></div>             </td>           </tr>                               <tr id="section-43">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-43">&#182;</a>               </div>               <p>This parser is wrapped in a function, executed immediately, because we want
to define locally some simpler parsers, not visible outside.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">stringLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">escapeSequence</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">decorate</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="s1">&#39;\\\\&#39;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;\\&#39;</span><span class="p">;</span> <span class="p">}),</span>
    <span class="nx">decorate</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="s1">&#39;\\\&#39;&#39;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;\&#39;&#39;</span><span class="p">;</span> <span class="p">}),</span>
    <span class="nx">decorate</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="s1">&#39;\\\&quot;&#39;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;\&quot;&#39;</span><span class="p">;</span> <span class="p">}),</span>
    <span class="nx">decorate</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="s1">&#39;\\n&#39;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}),</span>
    <span class="nx">decorate</span><span class="p">(</span><span class="nx">string</span><span class="p">(</span><span class="s1">&#39;\\t&#39;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;\t&#39;</span><span class="p">;</span> <span class="p">})</span>
  <span class="p">]);</span>

  <span class="kd">var</span> <span class="nx">contents</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">limiter</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span>
      <span class="nx">many</span><span class="p">(</span><span class="nx">choice</span><span class="p">([</span><span class="nx">escapeSequence</span><span class="p">,</span> <span class="nx">otherThanChars</span><span class="p">([</span><span class="nx">limiter</span><span class="p">,</span> <span class="s1">&#39;\\&#39;</span><span class="p">,</span> <span class="s1">&#39;\n&#39;</span><span class="p">])])),</span>
      <span class="kd">function</span> <span class="p">(</span><span class="nx">xs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">inSingleQuotes</span> <span class="o">=</span> <span class="nx">between</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">),</span> <span class="nx">contents</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">inDoubleQuotes</span> <span class="o">=</span> <span class="nx">between</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">),</span> <span class="nx">character</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">),</span> <span class="nx">contents</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">));</span>

  <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">lexeme</span><span class="p">(</span><span class="nx">choice</span><span class="p">([</span><span class="nx">inSingleQuotes</span><span class="p">,</span> <span class="nx">inDoubleQuotes</span><span class="p">])),</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">StringLiteral</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">);</span>
<span class="p">}();</span>

<span class="kd">var</span> <span class="nx">booleanLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">trueLiteral</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">BooleanLiteral</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">falseLiteral</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;false&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">BooleanLiteral</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">trueLiteral</span><span class="p">,</span> <span class="nx">falseLiteral</span><span class="p">]);</span>
<span class="p">}();</span></pre></div>             </td>           </tr>                               <tr id="section-44">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-44">&#182;</a>               </div>               <p>Many parsers need to be defined recursively. For example, an object literal
will contain expression, so we need to use expr parser. However, expr cannot
be defined yet, as it will need objectLiteral parser.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-45">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-45">&#182;</a>               </div>               <p>That's why we wrap such recursive parsers in functions.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">objectLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">identifier</span><span class="p">,</span> <span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">s_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nx">id</span><span class="p">,</span> <span class="nx">expr</span><span class="p">];</span> <span class="p">}</span>
  <span class="p">);</span>

  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">braces</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">pair</span><span class="p">)),</span></pre></div>             </td>           </tr>                               <tr id="section-46">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-46">&#182;</a>               </div>               <p>Our decorator function does not alter arguments at all, so we can pass
AST node constructor directly to decorate</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">AST</span><span class="p">.</span><span class="nx">ObjectLiteral</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">arrayLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span>
    <span class="nx">squares</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">)),</span>
    <span class="nx">AST</span><span class="p">.</span><span class="nx">ArrayLiteral</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">variable</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">identifier</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">Variable</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">functionLiteral</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">),</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">body</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">statements</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">FunctionLiteral</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">statements</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">invocation</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">parens</span><span class="p">(</span><span class="nx">sepBy</span><span class="p">(</span><span class="nx">symbol</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">)),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">Invocation</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">refinement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">dotStyle</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">([</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">d_</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">Refinement</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">StringLiteral</span><span class="p">(</span><span class="nx">key</span><span class="p">));</span>
    <span class="p">};</span>
  <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">squareStyle</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">squares</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">keyExpr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">Refinement</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">keyExpr</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">dotStyle</span><span class="p">,</span> <span class="nx">squareStyle</span><span class="p">])(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">preDecrement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">PreDecrement</span><span class="p">;</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">preIncrement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">PreIncrement</span><span class="p">;</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">postDecrement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">PostDecrement</span><span class="p">;</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">postIncrement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;++&quot;</span><span class="p">),</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">PostIncrement</span><span class="p">;</span>
<span class="p">});</span></pre></div>             </td>           </tr>                               <tr id="section-47">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-47">&#182;</a>               </div>               <p>This is the most complex parser.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">simple</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">numberLiteral</span><span class="p">,</span>
    <span class="nx">stringLiteral</span><span class="p">,</span>
    <span class="nx">booleanLiteral</span><span class="p">,</span>
    <span class="nx">objectLiteral</span><span class="p">,</span>
    <span class="nx">arrayLiteral</span><span class="p">,</span>
    <span class="nx">functionLiteral</span><span class="p">,</span>
    <span class="nx">variable</span><span class="p">,</span>
    <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
  <span class="p">]);</span></pre></div>             </td>           </tr>                               <tr id="section-48">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-48">&#182;</a>               </div>               <p>This is special use of decorate(): instead of returning AST node, we
return a function. chainl1 expects such functions and will apply them
to parsed arguments.
In final result there won't by any functions, only {binaryOp} nodes.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="kd">var</span> <span class="nx">binaryOp</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">BinaryOp</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="p">});</span>
  <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-49">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-49">&#182;</a>               </div>               <p>Similar to binaryOp, but creates unary functions.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="kd">var</span> <span class="nx">unaryOp</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">UnaryOp</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="p">});</span>
  <span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-50">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-50">&#182;</a>               </div>               <p>Suffix operators have highest priority. They can be denoted as () and [].</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nx">simple</span> <span class="o">=</span> <span class="nx">suffixOp</span><span class="p">(</span><span class="nx">simple</span><span class="p">,</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">invocation</span><span class="p">,</span> <span class="nx">refinement</span><span class="p">,</span> <span class="nx">postDecrement</span><span class="p">,</span> <span class="nx">postIncrement</span>
  <span class="p">]));</span></pre></div>             </td>           </tr>                               <tr id="section-51">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-51">&#182;</a>               </div>               <p>Prefix operators have precedence over all binary operators.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nx">simple</span> <span class="o">=</span> <span class="nx">prefixOp</span><span class="p">(</span><span class="nx">simple</span><span class="p">,</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)),</span> <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)),</span> <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)),</span>
    <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;new&quot;</span><span class="p">)),</span> <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">)),</span> <span class="nx">unaryOp</span><span class="p">(</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;typeof&quot;</span><span class="p">)),</span>
    <span class="nx">preDecrement</span><span class="p">,</span> <span class="nx">preIncrement</span>
  <span class="p">]));</span></pre></div>             </td>           </tr>                               <tr id="section-52">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-52">&#182;</a>               </div>               <p>Below we define binary operators in their order of precedence.
All of them are left-associative.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="kd">var</span> <span class="nx">complex</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;instanceof&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">keyword</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;===&quot;</span><span class="p">,</span> <span class="s2">&quot;!==&quot;</span><span class="p">,</span> <span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">)),</span>
    <span class="nx">choice</span><span class="p">([</span><span class="s2">&quot;||&quot;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">operator</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">binaryOp</span><span class="p">))</span>
  <span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">chainl1</span><span class="p">,</span> <span class="nx">simple</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">complex</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">varStatementWithoutAssignment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">VarStatement</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">varStatementWithAssignment</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">),</span> <span class="nx">identifier</span><span class="p">,</span> <span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">op_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">VarStatement</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">expr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">varStatement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span>
  <span class="nx">varStatementWithAssignment</span><span class="p">,</span> <span class="nx">varStatementWithoutAssignment</span><span class="p">]);</span>

<span class="kd">var</span> <span class="nx">assignStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">operator</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">lexpr</span><span class="p">,</span> <span class="nx">op_</span><span class="p">,</span> <span class="nx">rexpr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">AssignStatement</span><span class="p">(</span><span class="nx">lexpr</span><span class="p">,</span> <span class="nx">rexpr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">returnStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;return&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">ReturnStatement</span><span class="p">(</span><span class="nx">expr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="kd">var</span> <span class="nx">ifStatementWithoutElse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">statements</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">IfStatement</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">statements</span><span class="p">,</span> <span class="p">[]);</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">ifStatementWithElse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">)),</span>
      <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;else&quot;</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">statements1</span><span class="p">,</span> <span class="nx">k2_</span><span class="p">,</span> <span class="nx">statements2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">IfStatement</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">statements1</span><span class="p">,</span> <span class="nx">statements2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">ifStatement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span><span class="nx">ifStatementWithElse</span><span class="p">,</span> <span class="nx">ifStatementWithoutElse</span><span class="p">]);</span>

<span class="kd">var</span> <span class="nx">tryStatement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;try&quot;</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">)),</span>
      <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;catch&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">identifier</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">try_</span><span class="p">,</span> <span class="nx">tryStatements</span><span class="p">,</span> <span class="nx">catch_</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">catchStatements</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">TryStatement</span><span class="p">(</span><span class="nx">tryStatements</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">catchStatements</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">)(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">whileStatement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;while&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">condition</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">WhileStatement</span><span class="p">(</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">body</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">doWhileStatement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;do&quot;</span><span class="p">),</span> <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">)),</span> <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;while&quot;</span><span class="p">),</span> <span class="nx">parens</span><span class="p">(</span><span class="nx">expr</span><span class="p">)],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">k2_</span><span class="p">,</span> <span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">DoWhileStatement</span><span class="p">(</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">body</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-53">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-53">&#182;</a>               </div>               <p>for loop has the following form: for (initial; condition; finalize) { body }
When condition is omitted, it's assumed to be "true" expression.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">forStatement</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
    <span class="p">[</span>
      <span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;for&quot;</span><span class="p">),</span>
      <span class="nx">parens</span><span class="p">(</span><span class="nx">sequence</span><span class="p">(</span>
        <span class="p">[</span>
          <span class="nx">choice</span><span class="p">([</span><span class="nx">varStatement</span><span class="p">,</span> <span class="nx">exprStatement</span><span class="p">,</span> <span class="nx">emptyStatement</span><span class="p">]),</span>
          <span class="nx">semicolon</span><span class="p">,</span>
          <span class="nx">choice</span><span class="p">([</span><span class="nx">expr</span><span class="p">,</span> <span class="nx">ret</span><span class="p">({</span> <span class="nx">booleanLiteral</span><span class="o">:</span> <span class="kc">true</span> <span class="p">})]),</span>
          <span class="nx">semicolon</span><span class="p">,</span>
          <span class="nx">choice</span><span class="p">([</span><span class="nx">exprStatement</span><span class="p">,</span> <span class="nx">emptyStatement</span><span class="p">])</span>
        <span class="p">],</span>
        <span class="kd">function</span> <span class="p">(</span><span class="nx">initial</span><span class="p">,</span> <span class="nx">s1_</span><span class="p">,</span> <span class="nx">condition</span><span class="p">,</span> <span class="nx">s2_</span><span class="p">,</span> <span class="nx">finalize</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
            <span class="nx">initial</span><span class="o">:</span> <span class="nx">initial</span><span class="p">,</span> <span class="nx">condition</span><span class="o">:</span> <span class="nx">condition</span><span class="p">,</span> <span class="nx">finalize</span><span class="o">:</span> <span class="nx">finalize</span>
          <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">)),</span>
      <span class="nx">braces</span><span class="p">(</span><span class="nx">many</span><span class="p">(</span><span class="nx">statement</span><span class="p">))</span>
    <span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">k_</span><span class="p">,</span> <span class="nx">inParens</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">ForStatement</span><span class="p">(</span>
        <span class="nx">inParens</span><span class="p">.</span><span class="nx">initial</span><span class="p">,</span> <span class="nx">inParens</span><span class="p">.</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">inParens</span><span class="p">.</span><span class="nx">finalize</span><span class="p">,</span> <span class="nx">body</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">throwStatement</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">(</span>
  <span class="p">[</span><span class="nx">keyword</span><span class="p">(</span><span class="s2">&quot;throw&quot;</span><span class="p">),</span> <span class="nx">expr</span><span class="p">],</span>
  <span class="kd">function</span> <span class="p">(</span><span class="nx">t_</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">ThrowStatement</span><span class="p">(</span><span class="nx">expr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="nx">exprStatement</span> <span class="o">=</span> <span class="nx">decorate</span><span class="p">(</span><span class="nx">expr</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">AST</span><span class="p">.</span><span class="nx">ExpressionStatement</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">emptyStatement</span> <span class="o">=</span> <span class="nx">ret</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">semicolon</span> <span class="o">=</span> <span class="nx">lexeme</span><span class="p">(</span><span class="nx">character</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">));</span>

<span class="kd">var</span> <span class="nx">statement</span> <span class="o">=</span> <span class="nx">choice</span><span class="p">([</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">varStatement</span><span class="p">),</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">assignStatement</span><span class="p">),</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">returnStatement</span><span class="p">),</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">throwStatement</span><span class="p">),</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">exprStatement</span><span class="p">),</span>
    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">doWhileStatement</span><span class="p">),</span></pre></div>             </td>           </tr>                               <tr id="section-54">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-54">&#182;</a>               </div>               <p>if and try statements, unlike others, are not followed by a semicolon.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">ifStatement</span><span class="p">,</span>
    <span class="nx">tryStatement</span><span class="p">,</span>
    <span class="nx">whileStatement</span><span class="p">,</span>
    <span class="nx">forStatement</span><span class="p">,</span></pre></div>             </td>           </tr>                               <tr id="section-55">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-55">&#182;</a>               </div>               <p>But we want to allow programs with unnecessary semicolons, so we add
"empty" statement that parses to null.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">skipTrailing</span><span class="p">(</span><span class="nx">semicolon</span><span class="p">,</span> <span class="nx">emptyStatement</span><span class="p">)</span>
<span class="p">]);</span></pre></div>             </td>           </tr>                               <tr id="section-56">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-56">&#182;</a>               </div>               <p>A program consists of many statements.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="kd">var</span> <span class="nx">program</span> <span class="o">=</span> <span class="nx">many1</span><span class="p">(</span><span class="nx">statement</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-57">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-57">&#182;</a>               </div>               <p>We also skip any comments or whitespace at the beginning, because our lexeme
parsers take care only of trailing whitespace.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">program</span> <span class="o">=</span> <span class="nx">skipLeading</span><span class="p">(</span><span class="nx">whiteSpaceOrComments</span><span class="p">,</span> <span class="nx">program</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-58">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-58">&#182;</a>               </div>               <p>Only match complete parses.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">program</span> <span class="o">=</span> <span class="nx">notFollowedBy</span><span class="p">(</span><span class="nx">anyChar</span><span class="p">,</span> <span class="nx">program</span><span class="p">);</span></pre></div>             </td>           </tr>                               <tr id="section-59">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-59">&#182;</a>               </div>               <p>The runner for parsers. By default uses "program" parser.
It will apply parser to the input, reject any incomplete parses (i.e. those
with any remaining input) and return first AST from the list.
This is means that if there is more than one successful parse, all but first
one are discarded.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">exports</span><span class="p">.</span><span class="nx">parse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">parser</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">parser</span> <span class="o">=</span> <span class="nx">parser</span> <span class="o">||</span> <span class="nx">program</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">completeResults</span> <span class="o">=</span> <span class="nx">results</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ast</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">completeResults</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">success</span><span class="o">:</span> <span class="nx">completeResults</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">failure</span><span class="o">:</span> <span class="nx">results</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">};</span></pre></div>             </td>           </tr>                               <tr id="section-60">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-60">&#182;</a>               </div>               <p>Here we export any parsers that we want to test individually.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">exports</span><span class="p">.</span><span class="nx">expr</span> <span class="o">=</span> <span class="nx">expr</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">keyword</span> <span class="o">=</span> <span class="nx">keyword</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">operator</span> <span class="o">=</span> <span class="nx">operator</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">stringLiteral</span> <span class="o">=</span> <span class="nx">stringLiteral</span><span class="p">;</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 